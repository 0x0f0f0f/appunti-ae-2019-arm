\chapter{Microarchitettura}

\section{Datapath}

Il ciclo di esecuzione di un processore è

\begin{lstlisting}[frame=single]
while(true) {
    Instruction = fetch(PC) // PC = program counter
    decode(Instruction)
    exec(Instruction)
    update(PC)
}
\end{lstlisting}

Vedremo come implementare un piccolo processore che esegue un sottoinsieme delle istruzioni ARM,
suddiviso in due oggetti, la parte di controllo e il \textbf{datapath} (parte operativa).

I processori possono essere di diversi tipi:
\begin{itemize}
    \item \textbf{Single cycle}: esegue un singolo ciclo fetch-decode-execute per ogni ciclo di clock (tutto viene eseguito nell'intervallo di tempo in cui il segnale di clock è basso).
    % //TODO schema
    \item \textbf{Multi cycle}: può eseguire un istruzione in più cicli di clock, in genere, un ciclo per il fetch-decode, un ciclo per l'exec e un ciclo per il writeback (risposta)
    % //TODO schema
    \item \textbf{Pipeline}
\end{itemize}

\begin{note}
    \textbf{Prestazioni}

    La misura \textit{CPI} (Clock per Instruction) misura quanti cicli di clock $\tau$ sono necessari per eseguire un istruzione.
    Da tale misura possiamo dedurre, per ogni processore, il tempo necessario per eseguire un programma di $N$ istruzioni.
    Esso impiegherà $N \cdot CPI \cdot \tau $
\end{note}


\section{Processori Single Cycle}

Per realizzare un processore Single Cycle dobbiamo capire quali componenti (reti logiche e sequenziali) sono
necessari per realizzare il datapath. Possiamo inferire da i componenti necessari per mantenere lo stato del processore (Registri e memoria)
e l'insieme \textit{ISTR} di istruzioni che vogliamo implementare.

Vediamo i \textbf{componenti di stato}, il primo componente da utilizzare è una memoria per le istruzioni che riceverà in input
un indirizzo e restituirà in output l'\textbf{istruzione corrente}.

Il secondo componente necessario è una memoria dati (una RAM statica) che contiene la memoria sulla quale possiamo fare operazioni di \textit{load} e \textit{store}.
Ha bisogno di un solo indirizzo di memoria per la lettura e la scrittura, un input di clock, un input di \textit{write enable}, un indirizzo in input, un valore in input e un valore in output.

Il terzo componente necessario è una memoria multiporta statica che continene lo stato dei registri.
Riceverà in input 3 indirizzi (2 in lettura ed 1 in scrittura), un segnale di clock, uno di write enable, un valore in input e due in output.
Se il segnale \textit{write enable} è LOW, l'indirizzo in scrittura viene utilizzato per la lettura.
Sarà necessario un registro separato per mantenere il program counter, che riceverà sempre clock, write enable, input e restituirà il suo contenuto in output.

% //TODO schema dettagliato
% //TODO schema semplificato

\begin{defn}
\textbf{Implementare un'istruzione LDR (Load register)} \\
Vediamo come implementare un'istruzione \texttt{LDR} con offset immediato (pre-indice), prendiamo ad esempio
\begin{lstlisting}[style=arm]
ldr r0, [r1, #4]
\end{lstlisting}
Avremo il registro \texttt{pc} che punterà all'istruzione \texttt{ldr}. La memoria istruzioni conterrà l'istruzione all'indirizzo puntato da \texttt{pc}.
Caricheremo \texttt{r1} dal primo indirizzo di lettura della \textit{memoria registri} (nel suo output 1), a cui sommeremo  nella \textit{ALU} l'offset costante \texttt{\#4}.
Caricheremo dall'indirizzo sommato un valore dalla \textit{memoria dati}, che andrà in input alla memoria registri e verrà scritto all'indirizzo di scrittura,
in questo caso \texttt{r0}.
% //TODO SCHEMA
Se volessimo realizzare un offset variabile (un registro), come ad esempio
\begin{lstlisting}[style=arm]
ldr r0, [r1, r2]
\end{lstlisting}
Dovremmo utilizzare anche il secondo input/output di lettura della memoria registri, (il registro \texttt{r2}) come operando di somma della ALU.
Ciò ci fa notare che è necessario un multiplexer fra \textit{out2} della memoria registri e l'operando immediato per realizzare correttamente l'offset.
\end{defn}


\begin{defn}
\textbf{Implementare un'istruzione STR (Store register)} \\
Implementare un'istruzione di \textit{store} è simile all'implementazione di un istruzione di \textit{load}.
Il segnale \textit{write enable} della memoria registri sarà low. Leggerò dal primo output della memoria registri l'indirizzo in cui memorizzerò il valore,
dal secondo output della memoria registri il valore da memorizzare e opzionalmente, un registro di offset dal terzo output.
Il segnale \textit{write enable} della memoria dati sarà HIGH.
% //TODO ordine registri nella thumb
\end{defn}

\begin{defn}
\textbf{Implementare istruzioni di salto} \\
Per implementare le istruzioni di salto dobbiamo sommare un immediato
all'indirizzo corrente contenuto nel program counter, ed inserirlo di nuovo all'interno del program counter.
Abbiamo bisogno di un multiplexer posto fra l'uscita della memoria dati e l'uscita della ALU posta dopo gli output della memoria registri.
Collegheremo l'uscita di tale multiplexer all'ingresso del program counter, dove scriveremo il valore dell'istruzione dopo il salto.

Alla fine di un'istruzione \textit{non di salto} il program counter viene incrementato di 4 posizioni attraverso una ALU.
Ciò ci dice che è necessario avere un altro multiplexer in ingresso al program counter.
% //TODO
\end{defn}

\section{Realizzazione di un Datapath in Verilog}

\centerfig{1}{completesinglecycleprocessor.png}{Processore a ciclo singolo completo}

\centerfig{1}{datapath_quartus}{Datapath visualizzato in Quartus}

\includecode[verilog]{./verilog/datapath/dp.v}{Modulo Datapath}

\includecode[verilog]{./verilog/datapath/mux2.v}{Multiplexer da 2 linee da 32 bit}

\includecode[verilog]{./verilog/datapath/registro.v}{Registro da 32 bit}

\includecode[verilog]{./verilog/datapath/rom.v}{Memoria delle istruzioni READ ONLY.}

\includecode[verilog]{./verilog/datapath/alu4.v}{ALU che incrementa di 4 per PC}

\includecode[verilog]{./verilog/datapath/regfile.v}{File dei registri}

\includecode[verilog]{./verilog/datapath/alupiumeno.v}{ALU principale}

\includecode[verilog]{./verilog/datapath/m.v}{Memoria Principale}

\includecode[verilog]{./verilog/datapath/extend.v}{Extend degli immediati}

\includecode[verilog]{./verilog/datapath/test_dp.v}{Test bench del Datapath}

\section{Processore a ciclo multiplo}

\centerfig{1}{multicycleprocessor.png}{Processore a ciclo multiplo completo}

\begin{note}
    \textbf{Svantaggi del processore a ciclo singolo} \\
    Un processore a ciclo singolo ha 3 svantaggi degni di nota:
    \begin{enumerate}
        \item Richiede memorie separate per le istruzioni ed i dati, laddove i processori
        moderni hanno una singola memoria esterna al processore dove sono contenuti entrambi.
        \item Richiede un ciclo di clock lungo abbastanza per supportare l'operazione più lenta: \texttt{LDR}, anche se le
        altre istruzioni potrebbero essere molto più veloci.
        \item Richiede tre addizionatori, uno nella \texttt{ALU} principale e due per la logica del \textit{program counter}.
    \end{enumerate}
\end{note}

\begin{defn}
    \textbf{Processore a multiciclo} \\
    Un processore a ciclo multiplo risolve questi problemi separando un'istruzione
    in diversi passaggi più piccoli da eseguire ognuno in un ciclo di clock, e unendo la memoria dati e la memoria istruzioni.
    In ogni passaggio piccolo (\textit{short step})
    il processore può leggere o scrivere la memoria o il register file, o utilizzare la ALU. \@
    L'istruzione corrente viene letta in un passaggio, e i dati possono essere letti o scritti in un passaggio successivo,
    rendendo possibile l'utilizzo di una singola memoria. Per rendere un processore multiciclo, introduciamo dei registri aggiuntivi
    nel \textit{datapath}, uno posto dopo le due uscite dei registri in lettura del file dei registri, per memorizzare
    il contenuto di essi ed un registro posto dopo la memoria. In tale modo è possibile separare un'istruzione in più cicli di clock.
    Vediamo un esempio per l'istruzione \texttt{ldr}:

    \begin{enumerate}
        \item \texttt{fetch} dell'istruzione dalla memoria.
        \item Lettura del registro da cui caricare, \texttt{decode}.
        \item Applicazione dell'offset tramite la \textit{ALU}.
        \item \texttt{load} dalla memoria di un valore (memorizzato in un ulteriore registro aggiuntivo).
        \item Memorizzazione del valore letto dalla memoria nel registro destinazione.
    \end{enumerate}

    Per utilizzare soltanto una memoria per istruzioni e dati, abbiamo bisogno di introdurre un multiplexer di fronte alla memoria,
    che controllerà se l'indirizzo in lettura della memoria sarà dettato dal program counter o dal risultato dell'operazione precedente.
    Ciò necessita dell'introduzione di memoria nella \textit{parte di controllo} del processore, ovvero va resa la parte di controllo un automa.

    Nonostante in un processore multiciclo si impieghi leggermente di più per eseguire un'istruzione di memoria,
    ne otterremo che per realizzare istruzioni operative occorrono meno cicli di clock delle istruzioni di memoria,
    rendendo effettivamente più efficace e rapido il processore.
\end{defn}

\begin{figure}[H]
	\centering
	\caption{Esempio di della parte di controllo di un processore multiciclo. Vediamo soltanto le istruzioni \texttt{ldr} e \texttt{add} per semplicità}
	\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3.5cm]
	
	\node[state,initial] 	(A)                    {\texttt{fetch}};
	\node[state]         	(B) [below right of=A] 	   {\texttt{add} (\texttt{decode})};
	\node[state]         	(D) [below of=B] 	   {\texttt{add} (\texttt{ALU})};
	\node[state]            (E) [below of=D] 	   {\texttt{add} (\texttt{reg})};
    \node[state]         	(C) [below left of=A] 	   {\texttt{ldr} (\texttt{decode})};
    \node[state]         	(F) [below of=C] 	   {\texttt{ldr} (\texttt{offset})};
    \node[state]         	(G) [below of=F] 	   {\texttt{ldr} (\texttt{load})};
    \node[state]         	(H) [below of=G] 	   {\texttt{ldr} (\texttt{reg})};

    \path
    (A)		edge [] node {$OP = 00$ \text{\\} (operazioni aritmetico-logiche)} 		(B)
		    edge [] node {$OP = 01$ \text{\\} (operazioni di memoria)} 	            (C)
    (B)     edge [] node {} (D)
    (D)     edge [] node {} (E)
    (C)     edge [] node {} (F)
    (F)     edge [] node {} (G)
    (G)     edge [] node {} (H);
	\end{tikzpicture}
\end{figure}